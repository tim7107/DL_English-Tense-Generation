"""========================================================================================
                                           Import
========================================================================================"""
from __future__ import unicode_literals, print_function, division
import evaluate_score
import dataloader
import unicodedata
import string
import re
import random
import time
import math
import torch
import json
import torch.nn as nn
import os
import nltk
import matplotlib.ticker as ticker
import numpy as np
import torch.nn.functional as F
import matplotlib.pyplot as plt
plt.switch_backend('agg')
from io import open
from os import system
from torch import optim
from nltk.translate.bleu_score import SmoothingFunction, sentence_bleu
from tensorboardX import SummaryWriter




"""========================================================================================
The sample.py includes the following template functions:

1. Encoder, decoder
2. Training function
3. BLEU-4 score function
4. Gaussian score function

You have to modify them to complete the lab.
In addition, there are still other functions that you have to 
implement by yourself.

1. The reparameterization trick
2. Your own dataloader (design in your own way, not necessary Pytorch Dataloader)
3. Output your results (BLEU-4 score, conversion words, Gaussian score, generation words)
4. Plot loss/score
5. Load/save weights

There are some useful tips listed in the lab assignment.
You should check them before starting your lab.
========================================================================================"""

"""========================================================================================
                                    basic setting
========================================================================================"""
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
SOS_token = 0
EOS_token = 1
UKN_token = 2
MAX_LENGTH = 25
#----------Hyper Parameters----------#
hidden_size = 256
latent_size = 32
condition_size = 4
#The number of vocabulary
vocab_size = 28
teacher_forcing_ratio = 1
empty_input_ratio = 0.1
KLD_weight = 0.0


"""========================================================================================
                                   Definition of Function
========================================================================================"""
################################
#Example inputs of compute_bleu
################################
#The target word
reference = 'accessed'
#The word generated by your model
output = 'access'
#compute BLEU-4 score
def compute_bleu(output, reference):
    cc = SmoothingFunction()
    if len(reference) == 3:
        weights = (0.33,0.33,0.33)
    else:
        weights = (0.25,0.25,0.25,0.25)
    return sentence_bleu([reference], output,weights=weights,smoothing_function=cc.method1)


"""============================================================================
example input of Gaussian_score

words = [['consult', 'consults', 'consulting', 'consulted'],
['plead', 'pleads', 'pleading', 'pleaded'],
['explain', 'explains', 'explaining', 'explained'],
['amuse', 'amuses', 'amusing', 'amused'], ....]

the order should be : simple present, third person, present progressive, past
============================================================================"""
"""
   Gaussian_score
"""
def Gaussian_score(words):
    words_list = []
    score = 0
    yourpath = ''#should be your directory of train.txt
    with open(yourpath,'r') as fp:
        for line in fp:
            word = line.split(' ')
            word[3] = word[3].strip('\n')
            words_list.extend([word])
        for t in words:
            for i in words_list:
                if t == i:
                    score += 1
    return score/len(words)
"""
   kl loss
"""            
def kl_loss( mean , logvar):
    return torch.sum( 0.5* (-logvar + mean**2 + torch.exp(logvar) -1 ))
    
"""
   cyclical
"""
def kl_annealing_cyc( iters):
    slope = 0.001
    scope = (1.0 / slope)*2
    w = ( iters % scope) * slope
    if w > 1.0:
        w = 1.0
    return w
    
"""
   monotonic
"""
def kl_annealing_mono(iters):
    slope = 1/4000
    # scope = (1.0 / slope)*2
    w = iters  * slope
    if w > 1.0:
        w = 1.0
    return w

"""
   asMinutes
"""
def asMinutes(s):
    m = math.floor(s / 60)
    s -= m * 60
    return '%dm %ds' % (m, s)

"""
   timeSince
"""
def timeSince(since, percent):
    now = time.time()
    s = now - since
    es = s / (percent)
    rs = es - s
    return '%s (- %s)' % (asMinutes(s), asMinutes(rs))
"""
   EncoderRNN
"""
class EncoderRNN(nn.Module):
    def __init__(self, input_size, hidden_size):
        super(EncoderRNN, self).__init__()
        self.hidden_size = hidden_size
        self.embedding = nn.Embedding(input_size, hidden_size) #input_size : number of word , hidden_size : dim of each word
        self.lstm = nn.LSTM(hidden_size, hidden_size) #nn.LSTM(input_size, hidden_size) -> input size : dim of each word, hidden size : number of neurals 
        '''
           layer1 for mean
           layer2 for log_variance
        '''
        self.fc_layer_1 = nn.Linear(hidden_size, latent_size)
        self.fc_layer_2 = nn.Linear(hidden_size, latent_size)
        
    def forward(self, input, hidden,cell):
        embedded   = self.embedding(input).view(input.shape[0] , 1 , -1)
        output = embedded
        output, (hidden , cell) = self.lstm(output, (hidden , cell))
        mean   = self.fc_layer_1(hidden)
        log_var = self.fc_layer_2(hidden)
        return mean , log_var, hidden , cell
        
    def reparameter(self, mean , var, mode):
        if mode == "train" :
            epilson = torch.randn( size = list(var.shape)).cuda().to(device)
        elif mode == "eval":
            epilson = 0
            print("eplison using eval")
        elif mode == "gaussian":
            epilson = torch.randn( size = [1,1,latent_size]).cuda().to(device)
            return epilson
        z  = mean + torch.exp(var*0.5)*epilson
        return z
    
    def initHidden(self):
        return torch.zeros(1, 1, self.hidden_size, device=device)

"""
   DecoderRNN
"""
class DecoderRNN(nn.Module):
    def __init__(self, hidden_size, output_size , latent_size , condition_size):
        super(DecoderRNN, self).__init__()
        self.latent_to_hidden = nn.Linear( latent_size+condition_size , hidden_size)
        self.embedding = nn.Embedding(output_size, hidden_size)
        self.lstm = nn.LSTM(hidden_size, hidden_size)
        self.out = nn.Linear(hidden_size, output_size)
        self.softmax = nn.LogSoftmax(dim=1)

    def forward(self, input, hidden,cell):
        output = self.embedding(input).view(1, 1, -1)
        output = F.relu(output)
        output,(hidden , cell)= self.lstm(output, (hidden ,cell))
        output = self.out(output)
        return output, hidden , cell

    def initHidden(self):
        return torch.zeros(1, 1, self.hidden_size, device=device)

    
"""
   train
"""    
def train(input_tensor, target_tensor,target_condition, encoder, decoder, encoder_optimizer, decoder_optimizer, criterion, kl_w,teacher_forcing_ratio = 1.0):
    encoder.train()
    decoder.train()
    encoder_hidden = encoder.initHidden()
    encoder_cell   = encoder.initHidden()
    
    encoder_optimizer.zero_grad()
    decoder_optimizer.zero_grad()
    
    input_length = input_tensor.size(0)
    target_length = target_tensor.size(0)
    
    """**********************************************************
       target_condition : tensor([0, 0, 1, 0], device='cuda:0')
    **********************************************************"""
    condition    = target_condition.view(1,1,-1).float()
    entropy_loss = 0
    
    """*********************
       Encoder & Decoder
    *********************"""
    
    #----------sequence to sequence part for encoder----------#
    mean , log_var , encoder_hidden , encoder_cell = encoder(input_tensor, encoder_hidden , encoder_cell)
    z = encoder.reparameter( mean , log_var , "train")
	
    #----------sequence to sequence part for decoder----------#
    decoder_input = torch.tensor([[SOS_token]], device=device)
    decoder_hidden = encoder_hidden 
    decoder_cell   = torch.cat([z , condition] , dim = -1)
    decoder_cell   = decoder.latent_to_hidden(decoder_cell)
    use_teacher_forcing = True if random.random() < teacher_forcing_ratio else False
    
    
    if use_teacher_forcing:
        # Teacher forcing: Feed the GT target as the next input
        for idx in range(target_length):
            decoder_output, decoder_hidden , decoder_cell = decoder(decoder_input, decoder_hidden , decoder_cell)
            entropy_loss += criterion(decoder_output.view(1,-1), target_tensor[idx].view(-1))
            decoder_input = target_tensor[idx].view(1,-1)  # Teacher forcing
    
    else:
        # Without teacher forcing: use its own predictions as the next input
        for di in range(target_length):
            decoder_output, decoder_hidden , decoder_cell = decoder(decoder_input, decoder_hidden , decoder_cell)
            decoder_input = F.softmax(decoder_output,dim= -1).argmax(dim=-1).view(1,-1)
            entropy_loss += criterion(decoder_output.view(1,-1), target_tensor[di].view(-1))
            if decoder_input.item() == EOS_token:
                break
    """*********************
       Calculate LOSS
    *********************"""
    kldiver_loss = kl_loss(mean , log_var)
    loss = entropy_loss
    loss += kl_w * kldiver_loss
    loss.backward()
    encoder_optimizer.step()
    decoder_optimizer.step()
    return entropy_loss.item() / target_length , kldiver_loss.item() / target_length , loss.item() / target_length


"""
   trainIters
""" 
def trainIters(encoder, decoder ,path , method, n_iters=75000, print_every=1000, plot_every=100, learning_rate=0.01 , ratio = 1.0):
    start = time.time()
    plot_losses = []
    entropy_loss_total = 0  # Reset every print_every
    kl_loss_total   = 0
    loss_total = 0
    plot_loss_total = 0  # Reset every plot_every
    best_score = 0.
    kl_w = 0.
    encoder_optimizer = optim.SGD(encoder.parameters(), lr=learning_rate)
    decoder_optimizer = optim.SGD(decoder.parameters(), lr=learning_rate)
    
    """
       Own data loader
    """
    vocabulary = str()
    for voc in range(97 , 97+26):
        vocabulary += chr(voc)
    index2word =  {i+2 : c  for i, c in enumerate(vocabulary)}
    index2word[0] = 'SOS'
    index2word[1] = 'EOS'
    training_pairs = dataloader.read_training_data( n_iters , "train")
    criterion = nn.CrossEntropyLoss()
    
    """
       observe result
    """
    tb_path = './tensorboard/' + path
    encoder_path = "./checkpoint/" + path + "encoder/"
    decoder_path  = "./checkpoint/" + path + "decoder/" 
    total_path = [ tb_path , encoder_path , decoder_path]
    for idx , path in enumerate((total_path)):
        if not os.path.isdir(path):
            os.makedirs(path)
    tb = SummaryWriter(log_dir = tb_path)
    
    

    for iters in range(1, n_iters + 1):
        if method == "mono":
            kl_w = kl_annealing_mono( iters-1)
        elif method == "cyc":
            kl_w = kl_annealing_cyc( iters-1)
            
        training_pair = training_pairs[iters - 1]
        input_tensor  = training_pair

        """****************************************************
           delete SOS and tense
           input_tensor= [all]
           target_tensor = [9,16,,,,,,1] without SOS and tense
        ****************************************************"""
        target_tensor = training_pair[1:-4]
        target_condition = training_pair[-4:]
        entropy_loss , kl_loss , loss = train(input_tensor, target_tensor,target_condition, encoder,decoder, encoder_optimizer, decoder_optimizer, criterion , kl_w , ratio)
        entropy_loss_total += entropy_loss
        kl_loss_total      += kl_loss
        loss_total += loss
        plot_loss_total += entropy_loss
        
        """******************************
           Save model : Encode, Decode
        ******************************"""
        if iters % print_every == 0:
            save_name_en =  encoder_path + str(iters) + ".pkl"
            save_name_de =  decoder_path + str(iters) + ".pkl"
            entropy_loss_avg = entropy_loss_total / print_every
            kl_loss_avg      = kl_loss_total / print_every
            loss_avg         = loss_total / print_every
            entropy_loss_total = 0
            kl_loss_total = 0
            loss_total = 0
            score = evaluate_score.run_evaluate(encoder , decoder, False)
            if score > best_score:
                torch.save(encoder.state_dict(),save_name_en)
                torch.save(decoder.state_dict(),save_name_de)
                best_score = score
            print('%s (%d %d%%) %.4f %.4f %.4f' % (timeSince(start, iters/ n_iters),
                                         iters, iters/ n_iters * 100, entropy_loss_avg , kl_loss_avg , loss_avg)
                   , 'Blue score: %.4f' % (score*100),'%')

            tb.add_scalar("Blue v4 Score", score , str(iters))
            tb.add_scalar("Entropy Loss",entropy_loss_avg,str(iters))
            tb.add_scalar("KL divergence Loss",kl_loss_avg,str(iters))

"""*********************************************************************************
                                 Main code
*********************************************************************************"""
encoder = EncoderRNN(vocab_size, hidden_size).to(device)
decoder = DecoderRNN(hidden_size, vocab_size , latent_size, condition_size).to(device)
lr      = 1e-3
path    = "cyc_lr_20/"
method  = "cyc"
ratio   = 1.0
#trainIters(encoder, decoder,path , method, 200000, print_every=100 , learning_rate = lr , ratio = ratio)

#testing:
path_encoder = "/home/ubuntu/DL_LAB4/checkpoint/cyc_lr_20/encoder/136800"
path_decoder = "/home/ubuntu/DL_LAB4/checkpoint/cyc_lr_20/decoder/136800"
evaluate_score.test_run_evaluate(encoder,decoder,1,path_encoder,path_decoder)
#encoder = EncoderRNN(vocab_size, hidden_size).to(device)
#decoder = DecoderRNN(hidden_size, vocab_size, latent_size, condition_size).to(device)
evaluate_score.test_run_gaussian(encoder,decoder,1,path_encoder,path_decoder)
